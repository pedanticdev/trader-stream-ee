<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradeStreamEE - Market Data Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --text-primary: #333333;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow: rgba(0, 0, 0, 0.1);
            --card-bg: #ffffff;
        }

        :root.dark-theme {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --shadow: rgba(0, 0, 0, 0.3);
            --card-bg: #1e293b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 20px;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            background: var(--bg-secondary);
            padding: 24px 32px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow), 0 1px 2px var(--shadow);
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .nav-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.95em;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: #eff6ff;
            color: #1d4ed8;
        }

        h1 {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.5em;
            margin-bottom: 5px;
            font-weight: 800;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95em;
            font-weight: 500;
        }

        .status-bar {
            background: var(--bg-secondary);
            padding: 16px 32px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow), 0 1px 2px var(--shadow);
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }

        .status-indicator.connected {
            background: #10b981;
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            50% {
                opacity: 0.7;
                box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
            }
        }

        .status-indicator.connected {
            animation-name: pulseGreen;
        }

        @keyframes pulseGreen {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }

            50% {
                opacity: 0.7;
                box-shadow: 0 0 0 6px rgba(16, 185, 129, 0);
            }
        }

        .alert-warning {
            animation: flashWarning 1s ease-in-out infinite;
        }

        .alert-critical {
            animation: flashCritical 0.5s ease-in-out infinite;
        }

        @keyframes flashWarning {

            0%,
            100% {
                background-color: transparent;
            }

            50% {
                background-color: rgba(245, 158, 11, 0.2);
            }
        }

        @keyframes flashCritical {

            0%,
            100% {
                background-color: transparent;
            }

            50% {
                background-color: rgba(239, 68, 68, 0.3);
            }
        }

        .stat-value.alert-warning {
            color: #f59e0b;
        }

        .stat-value.alert-critical {
            color: #ef4444;
        }

        .stats-panel {
            background: var(--bg-secondary);
            padding: 20px 32px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow), 0 1px 2px var(--shadow);
            margin-bottom: 16px;
        }

        .stats-panel .stats {
            justify-content: center;
        }

        .stats {
            display: flex;
            gap: 40px;
        }

        .stat-group {
            display: flex;
            gap: 20px;
            padding-right: 20px;
            border-right: 1px solid #e2e8f0;
        }

        .stat-group:last-child {
            border-right: none;
        }

        .stat {
            text-align: center;
            min-width: 100px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #1976d2;
            font-variant-numeric: tabular-nums;
            min-width: 120px;
            display: inline-block;
        }

        .stat-value.backend {
            color: #7c3aed;
        }

        .stat-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            font-weight: 500;
            margin-top: 4px;
        }

        .status-mode {
            font-weight: 600;
            color: #1976d2;
            margin-left: 15px;
            padding: 6px 12px;
            border-radius: 4px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        @media (max-width: 1024px) {
            .data-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
                padding: 16px 20px;
            }

            h1 {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 0.85em;
            }

            header > div:last-child {
                flex-wrap: wrap;
                width: 100%;
                justify-content: flex-start;
                gap: 8px;
            }

            header select,
            header button,
            header a {
                flex: 1;
                min-width: 100px;
                padding: 8px 12px;
                font-size: 0.85em;
                text-align: center;
            }

            .status-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
                padding: 12px 16px;
            }

            .status-item {
                flex-wrap: wrap;
                gap: 8px;
            }

            #connectBtn {
                width: 100%;
            }

            .stats-panel {
                padding: 16px;
            }

            .stats {
                flex-direction: column;
                gap: 16px;
            }

            .stat-group {
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 16px;
                padding-right: 0;
                gap: 16px;
            }

            .stat-group:last-child {
                border-bottom: none;
                padding-bottom: 0;
            }

            .stat-value {
                font-size: 1.4em;
                min-width: auto;
            }

            .stress-scenarios {
                flex-direction: column;
                padding: 12px 16px;
                gap: 12px;
            }

            .scenario-buttons {
                width: 100%;
            }

            .scenario-btn {
                flex: 1;
                min-width: 70px;
                padding: 10px 12px;
                font-size: 0.85em;
            }

            .gc-comparison-panel {
                padding: 16px;
            }

            .gc-comparison-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .gc-comparison-header h2 {
                font-size: 1.2em;
            }

            .jvm-info {
                flex-wrap: wrap;
                font-size: 0.85em;
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .metric-card {
                padding: 12px;
            }

            .metric-value {
                font-size: 1.5em;
            }

            .gc-comparison-panel > div[style*="justify-content: space-between"] {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .gc-comparison-panel button {
                width: 100%;
            }

            .card-header {
                padding: 12px 16px;
                font-size: 0.95em;
                flex-wrap: wrap;
                gap: 8px;
            }

            .card-body {
                padding: 16px;
                max-height: 300px;
            }

            .card-body.chart-body {
                height: 250px;
            }

            .card-back {
                padding: 20px;
            }

            .card-back h3 {
                font-size: 1.2em;
            }

            .card-back p {
                font-size: 0.9em;
            }

            .flip-hint {
                display: none;
            }

            .message {
                padding: 10px;
                font-size: 0.75em;
            }

            button {
                padding: 12px 16px;
                font-size: 0.9em;
                min-height: 44px;
            }

            .scenario-btn {
                min-height: auto;
            }

            .chart-mode-label {
                font-size: 0.75em;
                padding: 3px 6px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
            }

            .subtitle {
                font-size: 0.8em;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .metric-value {
                font-size: 1.8em;
            }

            .stat-value {
                font-size: 1.2em;
            }

            .card-body.chart-body {
                height: 200px;
            }
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .card-container {
            perspective: 1000px;
            height: 100%;
        }

        .card {
            position: relative;
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow), 0 1px 2px var(--shadow);
            overflow: visible;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            cursor: pointer;
        }

        .card:hover {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.12), 0 4px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }

        .card.flipped .card-front {
            transform: rotateY(180deg);
        }

        .card.flipped .card-back {
            transform: rotateY(0deg);
        }

        .card-front,
        .card-back {
            width: 100%;
            backface-visibility: hidden;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            transform: rotateY(-180deg);
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            border-radius: 8px;
            padding: 30px;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .card-back h3 {
            font-size: 1.5em;
            margin-bottom: 16px;
            font-weight: 700;
        }

        .card-back p {
            font-size: 0.95em;
            line-height: 1.6;
            opacity: 0.95;
            font-weight: 400;
        }

        .card-back .tech-stack {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.85em;
            opacity: 0.9;
        }

        .flip-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7em;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .card:hover .flip-hint {
            opacity: 1;
        }

        .card-header {
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: white;
            padding: 16px 20px;
            font-weight: 600;
            font-size: 1.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .card-body {
            padding: 24px;
            max-height: 400px;
            overflow-y: auto;
        }

        .card-body::-webkit-scrollbar {
            width: 6px;
        }

        .card-body::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }

        .card-body::-webkit-scrollbar-thumb {
            background: #1976d2;
            border-radius: 10px;
        }

        .card-body.chart-body {
            max-height: none;
            overflow: hidden;
            height: 350px;
        }

        .message {
            padding: 14px;
            margin-bottom: 12px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 0.82em;
            border-left: 4px solid #1976d2;
            background: #f5f5f5;
            transition: all 0.2s;
        }

        .message:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .message.trade {
            border-left-color: #3b82f6;
        }

        .message.quote {
            border-left-color: #10b981;
        }

        .message.depth {
            border-left-color: #f59e0b;
        }

        .message-type {
            font-weight: 700;
            color: #1976d2;
            margin-bottom: 6px;
            text-transform: uppercase;
            font-size: 0.75em;
            letter-spacing: 0.05em;
        }

        .message-data {
            color: #475569;
        }

        .highlight {
            color: #1976d2;
            font-weight: 700;
        }

        button {
            background: #1976d2;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: #1565c0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        button.processing {
            opacity: 0.7;
            transform: scale(0.98);
        }

        button.processing::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            animation: slide 0.6s;
        }

        @keyframes slide {
            to {
                left: 100%;
            }
        }

        .chart-mode-label {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 500;
            color: white;
        }

        .gc-comparison-panel {
            background: white;
            padding: 24px 32px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            margin-bottom: 24px;
        }

        .gc-comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 16px;
        }

        .gc-comparison-header h2 {
            font-size: 1.5em;
            color: #1e293b;
            font-weight: 700;
        }

        .jvm-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.95em;
        }

        .badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.85em;
        }

        .badge.azul {
            background: #dbeafe;
            color: #1e40af;
        }

        .badge.standard {
            background: #dbeafe;
            color: #1e40af;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 24px;
        }

        .metric-card {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .metric-card h3 {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: 800;
            color: #0f172a;
            display: block;
        }

        .metric-unit {
            font-size: 0.8em;
            color: #94a3b8;
        }

        .status-indicator.excellent {
            color: #10b981;
        }

        .status-indicator.good {
            color: #3b82f6;
        }

        .status-indicator.warning {
            color: #f59e0b;
        }

        .status-indicator.critical {
            color: #ef4444;
            font-weight: bold;
        }

        .stress-scenarios {
            margin-bottom: 16px;
            background: white;
            padding: 16px 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 24px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .scenario-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .scenario-btn {
            background: white;
            color: #475569;
            border: 1px solid #cbd5e1;
            padding: 8px 16px;
            font-size: 0.9em;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            min-width: 120px;
        }

        .scenario-btn:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
            transform: translateY(-1px);
        }

        .scenario-btn.active {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .scenario-btn .hint {
            font-size: 0.7em;
            font-weight: 400;
            opacity: 0.8;
            text-transform: none;
        }
    </style>
</head>

<body>
<div class="container">
    <header>
        <div>
            <h1>TradeStreamEE</h1>
            <p class="subtitle">High-Frequency Trading Dashboard â€¢ Aeron + SBE + Payara Micro + Azul Platform Prime</p>
            </p>
        </div>
        <div style="display: flex; gap: 12px; align-items: center;">
            <select id="pollingInterval" onchange="setPollingInterval(this.value)"
                    style="background: var(--bg-secondary); color: var(--text-primary); border: 1px solid #64748b; cursor: pointer; padding: 8px 12px; border-radius: 6px; font-family: inherit;">
                <option value="1000">Poll: 1s</option>
                <option value="2000" selected>Poll: 2s</option>
                <option value="5000">Poll: 5s</option>
                <option value="10000">Poll: 10s</option>
                <option value="30000">Poll: 30s</option>
            </select>
            <button onclick="toggleDarkMode()" class="nav-link"
                    style="background: transparent; border: 1px solid #64748b; cursor: pointer; padding: 8px 16px;"
                    id="darkModeBtn">ðŸŒ™ Dark</button>
            <button onclick="exportStats('json')" class="nav-link"
                    style="background: transparent; border: 1px solid #3b82f6; cursor: pointer; padding: 8px 16px;">Export
                JSON</button>
            <button onclick="exportStats('csv')" class="nav-link"
                    style="background: transparent; border: 1px solid #3b82f6; cursor: pointer; padding: 8px 16px;">Export
                CSV</button>
            <a href="blog.html" class="nav-link">Read Blog</a>
        </div>
    </header>

    <div class="stats-panel">
        <div class="stats">
            <div class="stat-group">
                <div class="stat">
                    <div class="stat-value backend" id="backendRate">0</div>
                    <div class="stat-label">Local Msg/sec</div>
                </div>
                <div class="stat">
                    <div class="stat-value backend" id="backendTotal">0</div>
                    <div class="stat-label">Local Total</div>
                </div>
            </div>
            <div class="stat-group">
                <div class="stat">
                    <div class="stat-value backend" id="clusterTotal">0</div>
                    <div class="stat-label">Cluster Total</div>
                </div>
                <div class="stat">
                    <div class="stat-value backend" id="clusterRate">0</div>
                    <div class="stat-label">Cluster Msg/sec</div>
                </div>
            </div>
            <div class="stat-group">
                <div class="stat">
                    <div class="stat-value" id="messageRate">0</div>
                    <div class="stat-label">UI Msg/sec</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="messageCount">0</div>
                    <div class="stat-label">UI Received</div>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Disconnected</span>
            <div class="status-indicator" id="apiStatusIndicator" style="margin-left: 15px;"
                 title="REST API Connection"></div>
            <span id="lastUpdated" style="margin-left: 10px; font-size: 0.85em; color: #64748b;"></span>
            <span id="modeDisplay" class="status-mode"></span>
            <span id="instanceDisplay" class="status-mode"
                  style="margin-left: 15px; color: #1976d2; font-weight: 600;"></span>
        </div>
        <button id="connectBtn" onclick="toggleConnection()">Connect</button>
    </div>

    <div class="stress-scenarios">
        <h3 style="font-size: 1em; color: #64748b; font-weight: 600; text-transform: uppercase;">Demo Scenarios</h3>
        <div class="scenario-buttons">
            <button onclick="applyScenario('DEMO_BASELINE')" class="scenario-btn" id="btn-DEMO_BASELINE">
                ðŸ“Š Baseline
                <span class="hint">No HFT stress</span>
            </button>

            <button onclick="applyScenario('DEMO_NORMAL')" class="scenario-btn" id="btn-DEMO_NORMAL">
                ðŸ“ˆ Normal Trading
                <span class="hint">2 MB/sec + Bursts</span>
            </button>

            <button onclick="applyScenario('DEMO_STRESS')" class="scenario-btn" id="btn-DEMO_STRESS">
                ðŸ”¥ High Stress
                <span class="hint">1 GB/sec + Bursts</span>
            </button>

            <button onclick="applyScenario('DEMO_EXTREME')" class="scenario-btn" id="btn-DEMO_EXTREME">
                ðŸ’¥ Flash Crash
                <span class="hint">4 GB/sec + Bursts</span>
            </button>
        </div>
    </div>

    <div class="gc-comparison-panel">
        <div class="gc-comparison-header">
            <h2>GC Performance Comparison</h2>
            <div class="jvm-info">
                <span class="label">Instance:</span>
                <span id="instance-name" class="value" style="font-weight: 700; color: #2563eb;">Unknown</span>
                <span class="label" style="margin-left: 20px;">JVM:</span>
                <span id="jvm-name" class="value" style="font-weight: 600;">Detecting...</span>
                <span id="gc-type" class="badge">--</span>
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <h3 title="99th percentile of the last 500 GC pause events. Shows the worst 1% of recent pauses.">
                    P99 Percentile
                </h3>
                <span id="pause-p99" class="metric-value">-</span>
                <span class="metric-unit">ms</span>
                <div id="pause-p99-samples" style="font-size: 0.85em; color: #64748b; margin-top: 4px; font-weight: 500;">
                    (500 samples)
                </div>
                <div id="pause-p99-status" style="margin-top: 6px; font-weight: 600; font-size: 0.85em;"></div>
            </div>

            <div class="metric-card">
                <h3>Last GC Pause</h3>
                <span id="pause-last" class="metric-value">-</span>
                <span class="metric-unit">ms</span>
                <div style="font-size: 0.85em; color: #64748b; margin-top: 4px;">Most recent pause</div>
            </div>

            <div class="metric-card">
                <h3>Pause Time Max</h3>
                <span id="pause-max" class="metric-value">-</span>
                <span class="metric-unit">ms</span>
                <div style="font-size: 0.85em; color: #64748b; margin-top: 4px;">All-time since startup</div>
            </div>

            <div class="metric-card">
                <h3>SLA Violations</h3>
                <span id="sla-violations" class="metric-value">-</span>
                <span class="metric-unit">pauses > 10ms</span>
                <div style="font-size: 0.85em; color: #64748b; margin-top: 4px;">Total since startup</div>
            </div>

            <div class="metric-card">
                <h3>Allocation Rate</h3>
                <span id="alloc-rate" class="metric-value">-</span>
                <span class="metric-unit">MB/sec</span>
            </div>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding: 0 8px;">
            <div style="font-size: 0.85em; color: #64748b;">
                <span style="font-weight: 600;">P99 Window:</span>
                <span style="margin-left: 4px;">500 pauses (rolling)</span>
            </div>
            <button onclick="resetPauseStats()" style="font-size: 0.85em; padding: 6px 16px; background: #6c757d;">
                Reset Pause Stats
            </button>
        </div>
    </div>

    <div class="data-grid">
        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">
                    GC Pause Time (Live)
                    <span class="chart-mode-label" id="gcPauseCollectorName">--</span>
                    <span class="flip-hint">Click to learn</span>
                </div>
                <div class="card-body chart-body">
                    <canvas id="gcPauseChart"></canvas>
                </div>
            </div>
            <div class="card-back">
                <h3>GC Pause Time Monitor</h3>
                <p>Real-time visualization of garbage collection pause times. Lower is better.</p>
                <p><strong>Azul C4 (Pauseless):</strong> Flat line near zero. Collections happen concurrently
                    without stopping application threads.</p>
                <p><strong>G1GC (Stop-the-World):</strong> Visible spikes when GC pauses occur. Higher message rates
                    = higher pause times.</p>
                <p>This chart demonstrates why C4 is ideal for latency-sensitive applications - predictable,
                    consistent performance without pause spikes.</p>
                <div class="tech-stack">
                    <strong>API:</strong> /api/gc/stats<br>
                    <strong>Metric:</strong> Last pause duration (ms)<br>
                    <strong>Update Rate:</strong> Every 3 seconds
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">
                    GC Statistics
                    <span class="chart-mode-label" id="gcCollectorName">--</span>
                    <span class="flip-hint">Click to learn</span>
                </div>
                <div class="card-body">
                    <div class="message">
                        <div class="message-type">Collections</div>
                        <div class="message-data">
                            Total: <span class="highlight" id="gcCollectionCount">--</span><br>
                            Delta: <span class="highlight" id="gcCollectionDelta">--</span>/sec
                        </div>
                    </div>
                    <div class="message">
                        <div class="message-type">Collection Time</div>
                        <div class="message-data">
                            Total: <span class="highlight" id="gcCollectionTime">--</span> ms<br>
                            Avg: <span class="highlight" id="gcAvgTime">--</span> ms
                        </div>
                    </div>
                    <div class="message">
                        <div class="message-type">Heap Usage</div>
                        <div class="message-data">
                            <span class="highlight" id="heapUsed">--</span> / <span id="heapMax">--</span> MB<br>
                            <span class="highlight" id="heapPercent">--</span>% utilized
                        </div>
                    </div>
                    <div class="message" id="phaseBreakdownContainer" style="display: none;">
                        <div class="message-type">GC Phase Breakdown</div>
                        <div class="message-data" id="phaseBreakdownData" style="font-size: 0.85em; line-height: 1.6;">
                            <em>No phase data available</em>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-back">
                <h3>GC Statistics</h3>
                <p>Real-time garbage collection metrics. Collection <strong>count</strong> matters less than
                    <strong>pause duration</strong>.
                </p>
                <p><strong>G1GC:</strong> Fewer collections (48), but longer pauses (4ms avg). At 100k msg/sec, a
                    4ms pause = 400 dropped messages.</p>
                <p><strong>Azul C4:</strong> More collections (500), but sub-millisecond pauses (0.1ms avg). Same
                    load = only 10 dropped messages.</p>
                <p>C4 does work concurrently while G1GC batches cleanup into painful stops.</p>
                <div class="tech-stack">
                    <strong>Source:</strong> /metrics endpoint (Prometheus format)<br>
                    <strong>Key Metric:</strong> Avg pause time, not collection count
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">
                    GC Challenge Mode
                    <span class="chart-mode-label" id="pressureMode">OFF</span>
                    <span class="flip-hint">Click to learn</span>
                </div>
                <div class="card-body">
                    <div class="message">
                        <div class="message-type">Allocation Rate <span id="burstIndicator" style="color: #ef4444; font-weight: 700; display: none;">âš¡ BURST</span></div>
                        <div class="message-data">
                            <span class="highlight" id="pressureRate">0 MB/sec</span>
                        </div>
                    </div>
                    <div class="message" style="margin-top: 8px; padding: 10px; background: #f8fafc; border-left: 3px solid #3b82f6;">
                        <div class="message-type" style="font-size: 0.75em; margin-bottom: 4px;">HFT Pattern</div>
                        <div class="message-data" style="font-size: 0.8em; color: #475569;">
                            <span id="hftPattern">OrderBook â†’ MarketTick â†’ MarketDepth</span>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                        <button onclick="event.stopPropagation(); setPressureMode('OFF')"
                                style="flex: 1; background: #6c757d;">OFF<br><span style="font-size: 0.7em; font-weight: 400; opacity: 0.9;">No stress</span></button>
                        <button onclick="event.stopPropagation(); setPressureMode('LOW')"
                                style="flex: 1; background: #28a745;">LOW<br><span style="font-size: 0.7em; font-weight: 400; opacity: 0.9;">2 MB/sec + Bursts</span></button>
                        <button onclick="event.stopPropagation(); setPressureMode('MEDIUM')"
                                style="flex: 1; background: #ffc107; color: #333;">MEDIUM<br><span style="font-size: 0.7em; font-weight: 400; opacity: 0.9;">20 MB/sec + Bursts</span></button>
                        <button onclick="event.stopPropagation(); setPressureMode('HIGH')"
                                style="flex: 1; background: #fd7e14;">HIGH<br><span style="font-size: 0.7em; font-weight: 400; opacity: 0.9;">1 GB/sec + Bursts</span></button>
                        <button onclick="event.stopPropagation(); setPressureMode('EXTREME')"
                                style="flex: 1; background: #dc3545;">EXTREME<br><span style="font-size: 0.7em; font-weight: 400; opacity: 0.9;">4 GB/sec + Bursts</span></button>
                    </div>
                </div>
            </div>
            <div class="card-back">
                <h3>GC Challenge Mode</h3>
                <p>Uses realistic HFT allocation patterns to stress-test the GC. Rotates through OrderBook, MarketTick, and MarketDepth patterns that match actual trading system memory profiles.</p>
                <p><strong>Azul C4:</strong> Maintains low, consistent pause times even under EXTREME allocation
                    pressure with coordinated bursts. Concurrent collection keeps up.</p>
                <p><strong>G1GC:</strong> Pause times spike as allocation rate increases. Bursts cause severe stuttering in
                    message delivery and chart updates.</p>
                <p><strong>Rates:</strong> LOW=2MB/s, MEDIUM=20MB/s, HIGH=1GB/s, EXTREME=4GB/s</p>
                <p><strong>Bursts:</strong> All active modes include 3x allocation bursts every 5 seconds to simulate flash crashes and market events.</p>
                <div class="tech-stack">
                    <strong>Patterns:</strong> OrderBook (5KB), MarketTick (4KB), MarketDepth (6KB)<br>
                    <strong>Burst Multiplier:</strong> 3x every 5 seconds (all modes except OFF)
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">
                    Hiccup Monitor
                    <span class="chart-mode-label" id="chartModeLabel">Waiting...</span>
                    <span class="flip-hint">Click to learn</span>
                </div>
                <div class="card-body chart-body">
                    <canvas id="hiccupChart"></canvas>
                </div>
            </div>
            <div class="card-back">
                <h3>Hiccup Monitor</h3>
                <p>Tracks inter-arrival time gaps between messages. Spikes indicate "Stop-the-World" GC pauses where
                    the application freezes.</p>
                <p>With Azul C4's pauseless GC, you should see a flat line even at 100k+ msg/sec. Standard OpenJDK
                    G1GC shows frequent spikes as it struggles to clean up heap.</p>
                <div class="tech-stack">
                    <strong>Measured:</strong> Performance.now() delta between WebSocket messages
                </div>
            </div>
        </div>

        <div class="card full-width" style="margin-bottom: 20px;" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">
                    Real-Time Price Monitor (Live Feed)
                    <span class="flip-hint">Click to learn</span>
                </div>
                <div class="card-body chart-body">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>
            <div class="card-back">
                <h3>Price Monitor</h3>
                <p>Displays the last 20 trade prices received via WebSocket. Updates in real-time as messages stream
                    in.</p>
                <p>Watch for smooth, continuous updates with Aeron mode. Any stuttering indicates GC pauses blocking
                    the ingestion pipeline.</p>
                <div class="tech-stack">
                    <strong>Chart:</strong> Chart.js (Bar)<br>
                    <strong>Updates:</strong> On each Trade message
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">Recent Trades</div>
                <div class="card-body" id="tradesContainer"></div>
            </div>
            <div class="card-back">
                <h3>Trade Messages</h3>
                <p>Shows the 5 most recent trade executions decoded from SBE binary format. Each trade includes
                    timestamp, symbol, price, and quantity.</p>
                <div class="tech-stack">
                    <strong>SBE Template:</strong> Trade (ID: 1)<br>
                    <strong>Decoding:</strong> Zero-copy Flyweight pattern
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">Market Quotes</div>
                <div class="card-body" id="quotesContainer"></div>
            </div>
            <div class="card-back">
                <h3>Quote Messages</h3>
                <p>Displays bid/ask spreads for active symbols. Generated synthetically by the publisher and encoded
                    using SBE.</p>
                <div class="tech-stack">
                    <strong>SBE Template:</strong> Quote (ID: 2)<br>
                    <strong>Fields:</strong> Bid Price, Ask Price, Bid Size, Ask Size
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">Market Depth</div>
                <div class="card-body" id="depthContainer"></div>
            </div>
            <div class="card-back">
                <h3>Market Depth</h3>
                <p>Level 2 order book data showing buy/sell orders at different price levels. Demonstrates SBE's
                    ability to encode complex nested structures.</p>
                <div class="tech-stack">
                    <strong>SBE Template:</strong> MarketDepth (ID: 3)<br>
                    <strong>Structure:</strong> Repeating groups for each price level
                </div>
            </div>
        </div>

        <div class="card" onclick="flipCard(this)">
            <div class="card-front">
                <div class="card-header">System Log</div>
                <div class="card-body" id="logContainer"></div>
            </div>
            <div class="card-back">
                <h3>System Log</h3>
                <p>Connection events and diagnostic messages. Logs WebSocket lifecycle and ingestion mode switches.
                </p>
                <div class="tech-stack">
                    <strong>Purpose:</strong> Debugging and monitoring<br>
                    <strong>Events:</strong> Connect, Disconnect, Mode changes
                </div>
            </div>
        </div>
    </div>
</div>
<script>
    let ws = null, messageCount = 0, lastMessageTime = 0, messagesLastSecond = 0;
    let lastGcCount = 0, lastGcPollTime = 0;
    let priceChart = null;
    let hiccupChart = null;
    let gcPauseChart = null;
    let lastRateUpdate = Date.now();
    let maxGapInWindow = 0;
    let titleFlashInterval = null;
    let originalTitle = 'TradeStreamEE - Market Data Dashboard';
    let alertCount = 0;

    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.defaults.color = '#333';
    Chart.defaults.borderColor = 'rgba(0,0,0,0.1)';

    function initCharts() {
        const ctxPrice = document.getElementById('priceChart').getContext('2d');
        priceChart = new Chart(ctxPrice, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Trade Price',
                    data: [],
                    backgroundColor: '#667eea',
                    borderColor: '#5a67d8',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { display: true, grid: { display: false }, ticks: { font: { size: 10 } } },
                    y: { grid: { color: 'rgba(0,0,0,0.05)' }, ticks: { font: { size: 10 } } }
                }
            }
        });

        const ctxHiccup = document.getElementById('hiccupChart').getContext('2d');
        hiccupChart = new Chart(ctxHiccup, {
            type: 'line',
            data: {
                labels: Array(50).fill(''),
                datasets: [{
                    label: 'Pause Duration (ms)',
                    data: Array(50).fill(0),
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { display: false },
                    y: {
                        beginAtZero: true,
                        suggestedMax: 50,
                        grid: { color: 'rgba(0,0,0,0.05)' },
                        title: { display: true, text: 'Pause Duration (ms)', font: { size: 12, weight: 'bold' } }
                    }
                }
            }
        });

        const ctxGcPause = document.getElementById('gcPauseChart').getContext('2d');
        gcPauseChart = new Chart(ctxGcPause, {
            type: 'line',
            data: {
                labels: Array(50).fill(''),
                datasets: [{
                    label: 'GC Pause Time (ms)',
                    data: Array(50).fill(0),
                    borderColor: '#7c3aed',
                    backgroundColor: 'rgba(124, 58, 237, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { display: false },
                    y: {
                        beginAtZero: true,
                        suggestedMax: 10,
                        grid: { color: 'rgba(0,0,0,0.05)' },
                        title: { display: true, text: 'Pause Duration (ms)', font: { size: 12, weight: 'bold' } }
                    }
                }
            }
        });
    }

    function updateCharts() {
        if (!hiccupChart) return;

        const plotValue = maxGapInWindow > 10 ? maxGapInWindow : 0;

        hiccupChart.data.labels.push('');
        hiccupChart.data.datasets[0].data.push(plotValue);

        if (hiccupChart.data.labels.length > 50) {
            hiccupChart.data.labels.shift();
            hiccupChart.data.datasets[0].data.shift();
        }

        hiccupChart.update('none');
        maxGapInWindow = 0;
    }

    function updatePriceChart(price) {
        if (!priceChart) return;
        const now = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        priceChart.data.labels.push(now);
        priceChart.data.datasets[0].data.push(price);
        if (priceChart.data.labels.length > 50) {
            priceChart.data.labels.shift();
            priceChart.data.datasets[0].data.shift();
        }
        priceChart.update('none');
    }

    function pollGCPauseStats() {
        fetch(API_BASE + '/gc/stats')
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(stats => {
                if (stats && stats.length > 0) {
                    let maxPauseMs = 0;
                    let activeCollectors = [];
                    let heapUsed = 0;
                    let heapMax = 0;
                    let totalCollectionCount = 0;
                    let totalCollectionTime = 0;

                    stats.forEach(gcStat => {
                        const pause = gcStat.lastPauseDuration || 0;
                        if (pause > maxPauseMs) {
                            maxPauseMs = pause;
                        }
                        if (gcStat.collectionCount > 0) {
                            activeCollectors.push(gcStat.gcName);
                        }
                        if (gcStat.usedMemory && gcStat.totalMemory) {
                            heapUsed = gcStat.usedMemory;
                            heapMax = gcStat.totalMemory;
                        }

                        totalCollectionCount += (gcStat.collectionCount || 0);
                        totalCollectionTime += (gcStat.collectionTime || 0);
                    });

                    const now = Date.now();
                    if (lastGcPollTime > 0) {
                const timeDiff = (now - lastGcPollTime) / 1000;
                        const countDiff = totalCollectionCount - lastGcCount;

                        if (timeDiff > 0 && countDiff >= 0) {
                            const rate = countDiff / timeDiff;
                            document.getElementById('gcCollectionDelta').textContent = rate.toFixed(1);
                        }
                    }
                    lastGcCount = totalCollectionCount;
                    lastGcPollTime = now;

                    document.getElementById('gcCollectionCount').textContent = totalCollectionCount.toLocaleString();
                    document.getElementById('gcCollectionTime').textContent = totalCollectionTime.toLocaleString();

                    const avgTime = totalCollectionCount > 0 ? (totalCollectionTime / totalCollectionCount) : 0;
                    document.getElementById('gcAvgTime').textContent = avgTime.toFixed(2);

                    const heapUsedMB = heapUsed / (1024 * 1024);
                    const heapMaxMB = heapMax / (1024 * 1024);
                    const heapPercent = heapMax > 0 ? ((heapUsed / heapMax) * 100).toFixed(0) : 0;

                    document.getElementById('heapUsed').textContent = (isFinite(heapUsedMB) ? heapUsedMB : 0).toFixed(0);
                    document.getElementById('heapMax').textContent = (isFinite(heapMaxMB) ? heapMaxMB : 0).toFixed(0);
                    document.getElementById('heapPercent').textContent = heapPercent;

                    const heapPercentValue = parseFloat(heapPercent) || 0;
                    checkAlert('heapPercent', heapPercentValue, ALERT_THRESHOLDS.heapPercent);

                    const collectorNames = [...new Set(activeCollectors)].join(' / ');
                    document.getElementById('gcPauseCollectorName').textContent = collectorNames || '--';
                    document.getElementById('gcCollectorName').textContent = collectorNames || '--';

                    // Display phase breakdown if available
                    if (stats.length > 0 && stats[0].phaseBreakdown) {
                        const phaseBreakdown = stats[0].phaseBreakdown;
                        const phaseContainer = document.getElementById('phaseBreakdownContainer');
                        const phaseData = document.getElementById('phaseBreakdownData');

                        if (phaseBreakdown && Object.keys(phaseBreakdown).length > 0) {
                            phaseData.textContent = '';
                            for (const [phaseName, phaseStats] of Object.entries(phaseBreakdown)) {
                                const phaseLine = document.createElement('div');
                                const phaseNameEl = document.createElement('strong');
                                phaseNameEl.textContent = phaseName + ': ';
                                phaseLine.appendChild(phaseNameEl);
                                const statsText = document.createTextNode(
                                    `P99=${phaseStats.p99Ms.toFixed(2)}ms, Max=${phaseStats.maxMs.toFixed(2)}ms`
                                );
                                phaseLine.appendChild(statsText);
                                phaseData.appendChild(phaseLine);
                            }
                            phaseContainer.style.display = 'block';
                        } else {
                            phaseContainer.style.display = 'none';
                        }
                    }

                    if (gcPauseChart) {
                        gcPauseChart.data.labels.push('');
                        gcPauseChart.data.datasets[0].data.push(maxPauseMs);

                        if (gcPauseChart.data.labels.length > 50) {
                            gcPauseChart.data.labels.shift();
                            gcPauseChart.data.datasets[0].data.shift();
                        }

                        gcPauseChart.update('none');
                    }
                }
            })
            .catch(error => console.error('Error fetching GC pause stats:', error));
    }

    function setPressureMode(mode) {
        const buttons = document.querySelectorAll('[onclick*="setPressureMode"]');
        let clickedButton = null;
        buttons.forEach(btn => {
            if (btn.textContent.trim() === mode) {
                clickedButton = btn;
                btn.classList.add('processing');
            }
        });

        fetch(API_BASE + '/pressure/mode/' + mode, { method: 'POST' })
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(result => {
                if (clickedButton) {
                    clickedButton.classList.remove('processing');
                }
                if (result.success) {
                    addLog('Memory pressure mode set to: ' + mode);
                    pollPressureStatus();
                } else {
                    addLog('Error setting pressure mode: ' + result.error);
                }
            })
            .catch(error => {
                if (clickedButton) {
                    clickedButton.classList.remove('processing');
                }
                console.error('Error setting pressure mode:', error);
                addLog('Failed to set pressure mode: ' + error.message);
            });
    }

    let burstAnimationInterval = null;

    function pollPressureStatus() {
        fetch(API_BASE + '/pressure/status')
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(status => {
                const mode = status.currentMode || 'OFF';
                document.getElementById('pressureMode').textContent = mode;
                const bytesPerSecond = status.bytesPerSecond ?? 0;
                const rateMBps = isFinite(bytesPerSecond) ? (bytesPerSecond / (1024 * 1024)).toFixed(1) : '0';
                document.getElementById('pressureRate').textContent = rateMBps + ' MB/sec';

                // Show burst indicator for all active modes (except OFF)
                const burstIndicator = document.getElementById('burstIndicator');
                if (mode !== 'OFF') {
                    if (!burstAnimationInterval) {
                        burstAnimationInterval = setInterval(() => {
                            burstIndicator.style.display = 'inline';
                            setTimeout(() => {
                                burstIndicator.style.display = 'none';
                            }, 1000);
                        }, 5000);
                    }
                } else {
                    if (burstAnimationInterval) {
                        clearInterval(burstAnimationInterval);
                        burstAnimationInterval = null;
                    }
                    burstIndicator.style.display = 'none';
                }
            })
            .catch(error => console.error('Error fetching pressure status:', error));
    }

    const contextRoot = window.location.pathname.split('/')[1];
    const API_BASE = (contextRoot ? '/' + contextRoot : '') + '/api';

    const ALERT_THRESHOLDS = {
        p99Ms: { warning: 10, critical: 50 },
        maxMs: { warning: 20, critical: 100 },
        heapPercent: { warning: 75, critical: 90 },
        slaViolations: { warning: 10, critical: 100 }
    };

    function checkAlert(elementId, value, threshold) {
        const el = document.getElementById(elementId);
        if (!el) return;

        const wasCritical = el.classList.contains('alert-critical');
        el.classList.remove('alert-warning', 'alert-critical');

        if (value >= threshold.critical) {
            el.classList.add('alert-critical');
            if (!wasCritical && document.hidden) {
                alertCount++;
                updateTabTitle();
                updateFavicon('alert');
                flashTabTitle(`CRITICAL: ${elementId} = ${value}`);
            }
        } else if (value >= threshold.warning) {
            el.classList.add('alert-warning');
        }
    }

    let lastClusterTotal = 0;
    let lastClusterTime = Date.now();
    let apiHealthy = false;
    let lastApiSuccess = null;

    function updateApiStatus(healthy) {
        apiHealthy = healthy;
        const indicator = document.getElementById('apiStatusIndicator');
        if (indicator) {
            if (healthy) {
                indicator.classList.add('connected');
                indicator.title = 'REST API: Connected';
            } else {
                indicator.classList.remove('connected');
                indicator.title = 'REST API: Disconnected';
            }
        }
    }

    function toggleDarkMode() {
        const html = document.documentElement;
        const btn = document.getElementById('darkModeBtn');
        const isDark = html.classList.toggle('dark-theme');

        btn.textContent = isDark ? 'â˜€ï¸ Light' : 'ðŸŒ™ Dark';

        localStorage.setItem('darkMode', isDark);
    }

    function initDarkMode() {
        const savedDarkMode = localStorage.getItem('darkMode') === 'true';
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const shouldBeDark = savedDarkMode || (savedDarkMode === null && prefersDark);

        if (shouldBeDark) {
            document.documentElement.classList.add('dark-theme');
            document.getElementById('darkModeBtn').textContent = 'â˜€ï¸ Light';
        }
    }

    function updateFavicon(status) {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = status === 'connected' ? '#10b981' :
            status === 'alert' ? '#ef4444' : '#64748b';
        ctx.beginPath();
        ctx.arc(16, 16, 14, 0, 2 * Math.PI);
        ctx.fill();

        if (status === 'alert') {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('!', 16, 16);
        }

        const link = document.querySelector("link[rel*='icon']") || document.createElement('link');
        link.type = 'image/x-icon';
        link.rel = 'shortcut icon';
        link.href = canvas.toDataURL();
        document.getElementsByTagName('head')[0].appendChild(link);
    }

    function updateTabTitle() {
        if (titleFlashInterval) return;

        const isConnected = ws && ws.readyState === WebSocket.OPEN;
        const messageRate = document.getElementById('messageRate')?.textContent || '0';
        const status = isConnected ? 'âœ“' : 'âœ—';

        if (document.hidden && alertCount > 0) {
            document.title = `(${alertCount}) TradeStreamEE | Alerts`;
        } else {
            document.title = `TradeStreamEE ${status} | ${messageRate} msg/s`;
        }
    }

    function flashTabTitle(message, duration = 5000) {
        if (titleFlashInterval) clearInterval(titleFlashInterval);

        let visible = true;
        titleFlashInterval = setInterval(() => {
            document.title = visible ? `âš  ${message}` : originalTitle;
            visible = !visible;
        }, 1000);

        setTimeout(() => {
            clearInterval(titleFlashInterval);
            titleFlashInterval = null;
            updateTabTitle();
        }, duration);
    }

    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            alertCount = 0;
            updateTabTitle();
        }
    });

    let currentPollingInterval = 2000;

    function setPollingInterval(intervalMs) {
        intervalMs = parseInt(intervalMs);
        if (isNaN(intervalMs) || intervalMs < 1000) return;

        currentPollingInterval = intervalMs;

        if (window.instanceStatusInterval) {
            clearInterval(window.instanceStatusInterval);
            window.instanceStatusInterval = setInterval(pollInstanceStatus, currentPollingInterval);
        }

        if (window.gcComparisonInterval) {
            clearInterval(window.gcComparisonInterval);
            window.gcComparisonInterval = setInterval(pollGCComparison, currentPollingInterval);
        }

        if (window.pressureStatusInterval) {
            clearInterval(window.pressureStatusInterval);
            window.pressureStatusInterval = setInterval(pollPressureStatus, Math.max(3000, currentPollingInterval));
        }

        localStorage.setItem('pollingInterval', intervalMs);

        addLog(`Polling interval set to ${intervalMs / 1000}s`);
    }

    function initPollingInterval() {
        const savedInterval = localStorage.getItem('pollingInterval');
        if (savedInterval) {
            const interval = parseInt(savedInterval);
            if (!isNaN(interval) && interval >= 1000) {
                document.getElementById('pollingInterval').value = interval;
                setPollingInterval(interval);
            }
        }
    }

    function updateLastUpdated() {
        const el = document.getElementById('lastUpdated');
        if (el) {
            if (lastApiSuccess) {
                const seconds = Math.floor((Date.now() - lastApiSuccess) / 1000);
                el.textContent = 'Updated ' + seconds + 's ago';
            } else {
                el.textContent = 'No data yet';
            }
        }
    }

    function pollInstanceStatus() {
        fetch(API_BASE + '/status')
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(status => {
                lastApiSuccess = Date.now();
                updateApiStatus(true);
                updateLastUpdated();

                if (status.instance) {
                    document.getElementById('instanceDisplay').textContent = '[' + status.instance + ']';
                }

                if (status.publisher && status.publisher.clusterMessagesPublished !== undefined) {
                    const clusterTotal = status.publisher.clusterMessagesPublished ?? 0;
                    document.getElementById('clusterTotal').textContent = clusterTotal.toLocaleString();

                    const now = Date.now();
                    const timeDiff = (now - lastClusterTime) / 1000;
                    const messageDiff = clusterTotal - (lastClusterTotal ?? 0);
                    if (timeDiff > 0 && (lastClusterTotal ?? 0) > 0) {
                        const clusterRate = Math.round(messageDiff / timeDiff);
                        if (isFinite(clusterRate)) {
                            document.getElementById('clusterRate').textContent = clusterRate.toLocaleString();
                        }
                    }
                    lastClusterTotal = clusterTotal;
                    lastClusterTime = now;
                }
            })
            .catch(error => {
                console.error('Error fetching instance status:', error);
                updateApiStatus(false);
            });
    }

    async function applyScenario(scenario) {
        document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));

        const btn = document.getElementById('btn-' + scenario);
        if (btn) btn.classList.add('active');

        try {
            const response = await fetch(API_BASE + '/pressure/scenario/' + scenario, {
                method: 'POST'
            });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const result = await response.json();
            console.log('Applied scenario:', result);

            pollPressureStatus();

            addLog('Scenario applied: ' + result.description);
        } catch (error) {
            console.error('Error applying scenario:', error);
            addLog('Failed to apply scenario: ' + error.message);
        }
    }

    async function pollGCComparison() {
        try {
            const response = await fetch(API_BASE + '/gc/comparison');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            const instanceName = data.instanceName || 'unknown';
            document.getElementById('instance-name').textContent = instanceName;

            const instanceEl = document.getElementById('instance-name');
            if (instanceName.includes('c4')) {
                instanceEl.style.color = '#10b981';
            } else if (instanceName.includes('g1')) {
                instanceEl.style.color = '#10b981';
            } else {
                instanceEl.style.color = '#2563eb';
            }

            document.getElementById('jvm-name').textContent = data.jvmName || 'Unknown';
            const gcTypeEl = document.getElementById('gc-type');
            if (data.isAzulC4) {
                gcTypeEl.textContent = 'Azul C4';
                gcTypeEl.className = 'badge azul';
            } else {
                gcTypeEl.textContent = 'Standard G1';
                gcTypeEl.className = 'badge standard';
            }

            const p99Ms = data.pauseP99Ms ?? 0;
            const maxMs = data.pauseMaxMs ?? 0;
            const violations = data.slaViolations10ms ?? 0;
            const allocRate = data.allocationRateMBps ?? 0;
            const sampleSize = data.pauseSampleSize ?? 0;

            let lastPauseMs = 0;
            if (data.gcStats && data.gcStats.length > 0) {
                data.gcStats.forEach(stat => {
                    if (stat.lastPauseDuration > lastPauseMs) {
                        lastPauseMs = stat.lastPauseDuration;
                    }
                });
            }

            document.getElementById('pause-p99').textContent = (isFinite(p99Ms) ? p99Ms : 0).toFixed(2);
            document.getElementById('pause-last').textContent = (isFinite(lastPauseMs) ? lastPauseMs : 0).toFixed(2);
            document.getElementById('pause-max').textContent = (isFinite(maxMs) ? maxMs : 0).toFixed(2);
            document.getElementById('sla-violations').textContent = (isFinite(violations) ? violations : 0).toLocaleString();
            document.getElementById('alloc-rate').textContent = (isFinite(allocRate) ? allocRate : 0).toFixed(1);

            const p99SamplesEl = document.getElementById('pause-p99-samples');
            if (p99SamplesEl) {
                p99SamplesEl.textContent = `(${sampleSize} samples)`;
            }

            checkAlert('pause-p99', isFinite(p99Ms) ? p99Ms : 0, ALERT_THRESHOLDS.p99Ms);
            checkAlert('pause-max', isFinite(maxMs) ? maxMs : 0, ALERT_THRESHOLDS.maxMs);
            checkAlert('sla-violations', isFinite(violations) ? violations : 0, ALERT_THRESHOLDS.slaViolations);


            const p99Status = document.getElementById('pause-p99-status');
            const p99 = isFinite(p99Ms) ? p99Ms : 0;

            if (p99 < 1) {
                p99Status.className = 'status-indicator excellent';
                p99Status.textContent = 'âœ“ Excellent';
            } else if (p99 < 10) {
                p99Status.className = 'status-indicator good';
                p99Status.textContent = 'âœ“ Good';
            } else if (p99 < 50) {
                p99Status.className = 'status-indicator warning';
                p99Status.textContent = 'âš  Degraded';
            } else {
                p99Status.className = 'status-indicator critical';
                p99Status.textContent = 'âœ— Critical';
            }

        } catch (error) {
            console.error('Failed to fetch GC comparison metrics:', error);
        }
    }

    async function resetPauseStats() {
        try {
            const response = await fetch(API_BASE + '/gc/pauses/reset', { method: 'POST' });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const result = await response.json();
            console.log('Reset pause stats:', result);

            pollGCComparison();
            addLog('GC pause statistics reset');
        } catch (error) {
            console.error('Error resetting pause stats:', error);
            addLog('Failed to reset pause stats: ' + error.message);
        }
    }

    function flipCard(card) {
        card.classList.toggle('flipped');
    }

    function toggleConnection() { ws && ws.readyState === WebSocket.OPEN ? ws.close() : connect() }

    function connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const contextPath = window.location.pathname.replace(/\/[^\/]*\.html.*$/, '').replace(/\/$/, '');
        const wsUrl = `${protocol}//${window.location.host}${contextPath}/market-data`;

        addLog('Connecting to ' + wsUrl);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            document.getElementById('statusIndicator').classList.add('connected');
            document.getElementById('statusText').textContent = 'Connected';
            document.getElementById('connectBtn').textContent = 'Disconnect';
            addLog('WebSocket connected');
            lastMessageTime = performance.now();
            lastRateUpdate = Date.now();

            updateFavicon('connected');
            updateTabTitle();

            if (window.chartInterval) clearInterval(window.chartInterval);
            window.chartInterval = setInterval(updateCharts, 100);

            if (window.gcPauseStatsInterval) clearInterval(window.gcPauseStatsInterval);
            window.gcPauseStatsInterval = setInterval(pollGCPauseStats, currentPollingInterval);
            pollGCPauseStats();

            if (window.gcComparisonInterval) clearInterval(window.gcComparisonInterval);
            window.gcComparisonInterval = setInterval(pollGCComparison, currentPollingInterval);
            pollGCComparison();

            if (window.pressureStatusInterval) clearInterval(window.pressureStatusInterval);
            window.pressureStatusInterval = setInterval(pollPressureStatus, Math.max(3000, currentPollingInterval));
            pollPressureStatus();

            if (window.instanceStatusInterval) clearInterval(window.instanceStatusInterval);
            window.instanceStatusInterval = setInterval(pollInstanceStatus, currentPollingInterval);
            pollInstanceStatus();

            if (window.tabTitleInterval) clearInterval(window.tabTitleInterval);
            window.tabTitleInterval = setInterval(updateTabTitle, 1000);
        };
        ws.onclose = () => {
            document.getElementById('statusIndicator').classList.remove('connected');
            document.getElementById('statusText').textContent = 'Disconnected (Reconnecting...)';
            document.getElementById('connectBtn').textContent = 'Connect';
            document.getElementById('modeDisplay').textContent = '';
            document.getElementById('chartModeLabel').textContent = 'Disconnected';
            addLog('WebSocket disconnected. Attempting auto-reconnect in 3s...');

            updateFavicon('disconnected');
            updateTabTitle();
            if (window.tabTitleInterval) clearInterval(window.tabTitleInterval);

            if (window.chartInterval) clearInterval(window.chartInterval);
            if (window.gcComparisonInterval) clearInterval(window.gcComparisonInterval);
            if (window.gcPauseStatsInterval) clearInterval(window.gcPauseStatsInterval);
            setTimeout(connect, 3000);
        };
        ws.onerror = error => addLog('WebSocket error: ' + error);
        ws.onmessage = event => {
            let data = JSON.parse(event.data);
            if (data.wrapped && data.data) {
                data = data.data;
            }
            handleMessage(data);
        };
    }

    function handleMessage(data) {
        const nowPerf = performance.now();
        const gap = nowPerf - lastMessageTime;
        lastMessageTime = nowPerf;

        if (gap > maxGapInWindow) {
            maxGapInWindow = gap;
        }

        messageCount++;
        messagesLastSecond++;

        const nowEpoch = Date.now();
        if (nowEpoch - lastRateUpdate >= 1000) {
            document.getElementById('messageCount').textContent = messageCount.toLocaleString();
            document.getElementById('messageRate').textContent = messagesLastSecond.toLocaleString();
            messagesLastSecond = 0;
            lastRateUpdate = nowEpoch;
        }

        switch (data.type) {
            case 'trade':
                addTrade(data);
                updatePriceChart(data.price);
                break;
            case 'quote':
                addQuote(data);
                break;
            case 'depth':
                addDepth(data);
                break;
            case 'info':
                addLog(data.message);
                if (data.mode) {
                    const modeText = 'Mode: ' + data.mode;
                    document.getElementById('modeDisplay').textContent = modeText;
                    document.getElementById('chartModeLabel').textContent = modeText;
                }
                break;
            case 'stats':
                if (data.total != null && isFinite(data.total)) {
                    document.getElementById('backendTotal').textContent = data.total.toLocaleString();
                }
                if (data.rate != null && isFinite(data.rate)) {
                    document.getElementById('backendRate').textContent = parseInt(data.rate).toLocaleString();
                }
                break;
        }
    }

    function formatTime(timestamp) {
        if (!timestamp) return '';
        const d = new Date(timestamp);
        return d.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' }) + '.' + d.getMilliseconds().toString().padStart(3, '0');
    }

    function addTrade(data) { const c = document.getElementById('tradesContainer'), m = document.createElement('div'); m.className = 'message trade'; m.innerHTML = `<div class="message-type">TRADE #${data.tradeId} <span style="float:right;font-size:0.8em;font-weight:normal;">${formatTime(data.timestamp)}</span></div><div class="message-data"><strong>${data.symbol}</strong> ${data.side} <span class="highlight">${data.quantity}</span> @ <span class="highlight">$${data.price.toFixed(2)}</span></div>`; c.insertBefore(m, c.firstChild); if (c.children.length > 20) c.removeChild(c.lastChild) }
    function addQuote(data) { const c = document.getElementById('quotesContainer'), m = document.createElement('div'); m.className = 'message quote'; m.innerHTML = `<div class="message-type">${data.symbol} <span style="float:right;font-size:0.8em;font-weight:normal;">${formatTime(data.timestamp)}</span></div><div class="message-data">BID: <span class="highlight">${data.bid.size}</span> @ <span class="highlight">$${data.bid.price.toFixed(2)}</span><br>ASK: <span class="highlight">${data.ask.size}</span> @ <span class="highlight">$${data.ask.price.toFixed(2)}</span></div>`; c.insertBefore(m, c.firstChild); if (c.children.length > 20) c.removeChild(c.lastChild) }
    function addDepth(data) { const c = document.getElementById('depthContainer'), m = document.createElement('div'); m.className = 'message depth'; let bids = data.bids.map(b => `${b.quantity}@$${b.price.toFixed(2)}`).join(', '), asks = data.asks.map(a => `${a.quantity}@$${a.price.toFixed(2)}`).join(', '); m.innerHTML = `<div class="message-type">${data.symbol} DEPTH <span style="float:right;font-size:0.8em;font-weight:normal;">${formatTime(data.timestamp)}</span></div><div class="message-data" style="font-size:0.75em;"><strong>BIDS:</strong> ${bids}<br><strong>ASKS:</strong> ${asks}</div>`; c.insertBefore(m, c.firstChild); if (c.children.length > 10) c.removeChild(c.lastChild) }
    function addLog(message) { const c = document.getElementById('logContainer'), m = document.createElement('div'); m.className = 'message info'; m.innerHTML = `<div class="message-data">${new Date().toLocaleTimeString('en-US', { hour12: false })}: ${message}</div>`; c.insertBefore(m, c.firstChild); if (c.children.length > 30) c.removeChild(c.lastChild) }

    function gatherCurrentStats() {
        const now = new Date().toISOString();
        return {
            timestamp: now,
            instance: document.getElementById('instanceDisplay')?.textContent?.replace(/[\[\]]/g, '') || 'unknown',
            websocket: {
                status: document.getElementById('statusText')?.textContent || 'unknown',
                messageRate: parseInt(document.getElementById('messageRate')?.textContent?.replace(/,/g, '') || 0),
                messageCount: parseInt(document.getElementById('messageCount')?.textContent?.replace(/,/g, '') || 0)
            },
            backend: {
                localRate: parseInt(document.getElementById('backendRate')?.textContent?.replace(/,/g, '') || 0),
                localTotal: parseInt(document.getElementById('backendTotal')?.textContent?.replace(/,/g, '') || 0),
                clusterRate: parseInt(document.getElementById('clusterRate')?.textContent?.replace(/,/g, '') || 0),
                clusterTotal: parseInt(document.getElementById('clusterTotal')?.textContent?.replace(/,/g, '') || 0)
            },
            memory: {
                heapUsed: document.getElementById('heapUsed')?.textContent || '0',
                heapMax: document.getElementById('heapMax')?.textContent || '0',
                heapPercent: document.getElementById('heapPercent')?.textContent || '0'
            },
            gc: {
                collectorName: document.getElementById('gcCollectorName')?.textContent || 'unknown',
                collectionCount: document.getElementById('gcCollectionCount')?.textContent || '0',
                collectionsPerSec: document.getElementById('gcCollectionDelta')?.textContent || '0',
                totalCollectionTime: document.getElementById('gcCollectionTime')?.textContent || '0',
                avgTime: document.getElementById('gcAvgTime')?.textContent || '0'
            },
            gcPerformance: {
                p99Ms: document.getElementById('pause-p99')?.textContent || '0',
                maxMs: document.getElementById('pause-max')?.textContent || '0',
                slaViolations: document.getElementById('sla-violations')?.textContent?.replace(/,/g, '') || '0',
                allocRate: document.getElementById('alloc-rate')?.textContent || '0'
            },
            pressure: {
                mode: document.getElementById('pressureMode')?.textContent || 'OFF',
                rate: document.getElementById('pressureRate')?.textContent || '0'
            }
        };
    }

    function exportStats(format) {
        const stats = gatherCurrentStats();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        let content, filename, mimeType;

        if (format === 'json') {
            content = JSON.stringify(stats, null, 2);
            filename = `tradestream-stats-${timestamp}.json`;
            mimeType = 'application/json';
        } else if (format === 'csv') {
            const flat = {
                timestamp: stats.timestamp,
                instance: stats.instance,
                websocket_status: stats.websocket.status,
                websocket_messageRate: stats.websocket.messageRate,
                websocket_messageCount: stats.websocket.messageCount,
                backend_localRate: stats.backend.localRate,
                backend_localTotal: stats.backend.localTotal,
                backend_clusterRate: stats.backend.clusterRate,
                backend_clusterTotal: stats.backend.clusterTotal,
                memory_heapUsed: stats.memory.heapUsed,
                memory_heapMax: stats.memory.heapMax,
                memory_heapPercent: stats.memory.heapPercent,
                gc_collectorName: stats.gc.collectorName,
                gc_collectionCount: stats.gc.collectionCount,
                gc_collectionsPerSec: stats.gc.collectionsPerSec,
                gc_totalCollectionTime: stats.gc.totalCollectionTime,
                gc_avgTime: stats.gc.avgTime,
                gcPerformance_p99Ms: stats.gcPerformance.p99Ms,
                gcPerformance_maxMs: stats.gcPerformance.maxMs,
                gcPerformance_slaViolations: stats.gcPerformance.slaViolations,
                gcPerformance_allocRate: stats.gcPerformance.allocRate,
                pressure_mode: stats.pressure.mode,
                pressure_rate: stats.pressure.rate
            };
            content = Object.keys(flat).join(',') + '\n' + Object.values(flat).join(',');
            filename = `tradestream-stats-${timestamp}.csv`;
            mimeType = 'text/csv';
        }

        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        addLog(`Stats exported as ${format.toUpperCase()}: ${filename}`);
    }

    window.addEventListener('load', () => {
        initDarkMode();
        initPollingInterval();
        initCharts();
        pollInstanceStatus();
        updateLastUpdated();
        setInterval(updateLastUpdated, 1000);

        updateFavicon('disconnected');
        updateTabTitle();

        setTimeout(connect, 1000);
    });
</script>
</body>

</html>