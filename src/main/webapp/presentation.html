<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Pauseless Java for Financial Systems: Azul C4 + Payara Micro</title>
    <link href="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/dist/reset.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/dist/reveal.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/dist/theme/black.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/highlight/monokai.css" rel="stylesheet">
    <style>
        :root {
            --payara-orange: #F0981B;
            --payara-dark: #1a1a1a;
            --payara-light: #ffffff;
        }

        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            font-size: 28px;
            line-height: 1.35;
            position: relative;
        }

        .reveal::after {
            content: "";
            position: fixed;
            top: 24px;
            left: 32px;
            width: 140px;
            height: 52px;
            background: url("images/payara.png") no-repeat center / contain;
            z-index: 1000;
            pointer-events: none;
        }

        .reveal h1, .reveal h2, .reveal h3 {
            color: var(--payara-orange);
            text-transform: none;
        }

        .reveal h1 {
            font-size: 2.2em;
            font-weight: 700;
        }

        .reveal h2 {
            font-size: 1.8em;
        }

        .reveal h3 {
            font-size: 1.35em;
        }

        .reveal .payara-logo {
            width: 300px;
            margin: 20px auto;
        }

        .reveal .highlight {
            color: var(--payara-orange);
            font-weight: 600;
        }

        .reveal code {
            background: #2d2d2d;
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--payara-orange);
        }

        .reveal pre code {
            padding: 12px;
            font-size: 0.85em;
            line-height: 1.4;
            background: #1e1e1e;
            border: 1px solid rgba(240, 152, 27, 0.3);
            border-radius: 8px;
        }

        .reveal .two-column pre code {
            font-size: 0.72em;
            padding: 8px;
            line-height: 1.35;
        }

        .reveal .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .reveal .box {
            background: rgba(240, 152, 27, 0.1);
            border: 2px solid var(--payara-orange);
            border-radius: 10px;
            padding: 20px;
        }

        .reveal .box h3 {
            margin-top: 0;
            font-size: 1.3em;
        }

        .reveal table {
            font-size: 0.8em;
            width: 100%;
        }

        .reveal table th {
            background: var(--payara-orange);
            color: var(--payara-dark);
        }

        .reveal table td {
            background: rgba(255,255,255,0.05);
        }

        .reveal ul, .reveal ol {
            font-size: 0.85em;
        }

        .reveal .architecture-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .reveal .arch-box {
            background: rgba(240, 152, 27, 0.2);
            border: 3px solid var(--payara-orange);
            border-radius: 10px;
            padding: 15px;
            min-width: 100px;
            text-align: center;
        }

        .reveal .arrow {
            font-size: 1.8em;
            color: var(--payara-orange);
        }

        .reveal .success {
            color: #51cf66;
        }

        .reveal .failure {
            color: #ff6b6b;
        }

        .reveal .metric-large {
            font-size: 3em;
            font-weight: 700;
            color: var(--payara-orange);
        }

        .reveal .metric-label {
            font-size: 0.9em;
            color: #888;
        }

        .reveal .comparison-row {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .reveal .comparison-item {
            text-align: center;
            padding: 20px;
        }

        .reveal .gc-timeline {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 10px 0;
            font-family: monospace;
        }

        .reveal .gc-block {
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            border-radius: 3px;
        }

        .reveal .gc-app { background: #51cf66; color: #000; }
        .reveal .gc-pause { background: #ff6b6b; color: #fff; }
        .reveal .gc-concurrent { background: var(--payara-orange); color: #fff; }

        .reveal .layers {
            background: rgba(240, 152, 27, 0.05);
            border-left: 5px solid var(--payara-orange);
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <!-- Slide 1: Title -->
        <section>
            <img alt="Payara" class="payara-logo" src="images/payara-fish-logo.svg">
            <h1>Pauseless Java for Financial Systems</h1>
            <h3>Azul C4 + Payara Micro for Low-Latency Trading</h3>
            <p style="margin-top: 60px; font-size: 1.1em;">
                <strong>TradeStreamEE</strong><br>
                A Reference Architecture for High-Frequency Trading
            </p>
        </section>

        <!-- Section: The Problem -->
        <section>
            <h1 style="color: var(--payara-orange);">Part 1</h1>
            <h2>The Problem</h2>
            <p>Why GC pauses matter in financial systems</p>
        </section>

        <!-- Slide 2: The Problem -->
        <section>
            <h2>The Problem: GC Pauses in Financial Systems</h2>
            <h3>Why Traditional Java Struggles with HFT</h3>
            <div class="two-column">
                <div class="box">
                    <h3>The Challenge</h3>
                    <ul>
                        <li>HFT processes 50,000-100,000+ messages/second</li>
                        <li>Latency budgets measured in microseconds</li>
                        <li>Single 50ms pause = missed trades</li>
                        <li>Unpredictable latency violates SLAs</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>The Cause</h3>
                    <ul>
                        <li>G1 uses stop-the-world pauses</li>
                        <li>All application threads halt during GC</li>
                        <li>Pause time scales with heap size</li>
                        <li>Mixed collections can exceed 100ms</li>
                    </ul>
                </div>
            </div>
            <p style="margin-top: 30px;">
                A 100ms pause at 10,000 messages/second = <span class="failure">1,000 messages delayed</span>
            </p>
        </section>

        <!-- Slide 3: GC Fundamentals -->
        <section>
            <h2>Garbage Collection Fundamentals</h2>
            <h3>Key Terminology</h3>
            <table>
                <tr>
                    <th>Term</th>
                    <th>Definition</th>
                </tr>
                <tr>
                    <td><strong>Young Generation</strong></td>
                    <td>Where new objects are allocated. Collected frequently.</td>
                </tr>
                <tr>
                    <td><strong>Old Generation</strong></td>
                    <td>Where long-lived objects reside after surviving young GCs.</td>
                </tr>
                <tr>
                    <td><strong>Promotion</strong></td>
                    <td>Moving objects from young to old generation.</td>
                </tr>
                <tr>
                    <td><strong>Live Set</strong></td>
                    <td>Total reachable objects. Larger = more GC work.</td>
                </tr>
                <tr>
                    <td><strong>Stop-the-World</strong></td>
                    <td>All application threads pause for GC to complete.</td>
                </tr>
                <tr>
                    <td><strong>Concurrent Collection</strong></td>
                    <td>GC runs alongside application threads. No pause.</td>
                </tr>
            </table>
        </section>

        <!-- Slide 4: G1 vs C4 Visual -->
        <section>
            <h2>G1 vs C4: Execution Timeline</h2>
            <h3>What Happens During Collection</h3>
            <div class="box" style="margin: 20px 0;">
                <h3 style="color: #ff6b6b;">G1GC (Stop-the-World)</h3>
                <div class="gc-timeline">
                    <div class="gc-block gc-app" style="width: 100px;">App</div>
                    <div class="gc-block gc-pause" style="width: 40px;">STOP</div>
                    <div class="gc-block gc-app" style="width: 80px;">App</div>
                    <div class="gc-block gc-pause" style="width: 60px;">STOP</div>
                    <div class="gc-block gc-app" style="width: 120px;">App</div>
                    <div class="gc-block gc-pause" style="width: 100px;">MIXED</div>
                    <div class="gc-block gc-app" style="width: 80px;">App</div>
                </div>
                <p style="font-size: 0.8em; margin-top: 10px;">Application threads halt during red blocks. Latency spikes occur.</p>
            </div>
            <div class="box" style="margin: 20px 0;">
                <h3 style="color: #51cf66;">Azul C4 (Concurrent)</h3>
                <div class="gc-timeline">
                    <div class="gc-block gc-app" style="width: 100%;">Application runs continuously</div>
                </div>
                <div class="gc-timeline" style="margin-top: 5px;">
                    <div class="gc-block gc-concurrent" style="width: 30%;">Mark</div>
                    <div class="gc-block" style="width: 10%; background: transparent;"></div>
                    <div class="gc-block gc-concurrent" style="width: 25%;">Relocate</div>
                    <div class="gc-block" style="width: 10%; background: transparent;"></div>
                    <div class="gc-block gc-concurrent" style="width: 25%;">Remap</div>
                </div>
                <p style="font-size: 0.8em; margin-top: 10px;">GC runs concurrently. Application never stops. Flat latency profile.</p>
            </div>
        </section>

        <!-- Slide 5: G1 Architectural Weaknesses -->
        <section>
            <h2>G1's Architectural Limitations</h2>
            <h3>Why Stop-the-World is Unavoidable</h3>
            <div class="two-column">
                <div>
                    <h3 style="color: #ff6b6b;">Mixed Collections</h3>
                    <ul>
                        <li>Must trace entire live set</li>
                        <li>Pause scales with heap size</li>
                        <li>2GB heap: 50-100ms pauses</li>
                        <li>4GB heap: 100-200ms pauses</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: #ff6b6b;">Remembered Sets</h3>
                    <ul>
                        <li>Track old-to-young references</li>
                        <li>Write barrier on every pointer update</li>
                        <li>Scanned during young GC</li>
                        <li>Overhead proportional to cross-refs</li>
                    </ul>
                </div>
            </div>
            <div class="box" style="margin-top: 30px;">
                <h3>Compaction Pauses</h3>
                <p>When heap fragments, G1 must stop all threads to compact memory. Small objects with random lifetimes trigger frequent compaction. No concurrent solution in G1.</p>
            </div>
        </section>

        <!-- Slide 6: C4 Architecture -->
        <section>
            <h2>Azul C4/GPGC: Concurrent by Design</h2>
            <h3>How Pauseless Collection Works</h3>
            <div class="two-column">
                <div class="box">
                    <h3>Read Barriers (LVB)</h3>
                    <ul>
                        <li>Loaded Value Barrier on every read</li>
                        <li>Relocate objects on-the-fly</li>
                        <li>Enables concurrent compaction</li>
                        <li>Small overhead, huge benefit</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Concurrent Generations</h3>
                    <ul>
                        <li>Has young (New) and old generations</li>
                        <li>Both collected concurrently</li>
                        <li>No STW for generational collection</li>
                        <li>No remembered set scanning pauses</li>
                    </ul>
                </div>
            </div>
            <div style="margin-top: 30px; text-align: center;">
                <p><span class="highlight">Result:</span> Sub-millisecond pauses regardless of heap size or live set.</p>
                <p style="font-size: 0.75em; color: #888;">C4 = algorithm name; GPGC (Generational Pauseless GC) = collector implementation in JMX</p>
            </div>
        </section>

        <!-- Slide 7: Scenario-Based Testing -->
        <section>
            <h2>Testing GC Behavior: Scenario Approach</h2>
            <h3>Targeting Specific Collector Weaknesses</h3>
            <table>
                <tr>
                    <th>Scenario</th>
                    <th>Rate</th>
                    <th>Live Set</th>
                    <th>G1 Weakness Tested</th>
                </tr>
                <tr>
                    <td><code>STEADY_LOAD</code></td>
                    <td>200 MB/s</td>
                    <td>512 MB</td>
                    <td>Young GC pause frequency</td>
                </tr>
                <tr>
                    <td><code>GROWING_HEAP</code></td>
                    <td>150 MB/s</td>
                    <td>100MB → 2GB</td>
                    <td>Mixed collection pause scaling</td>
                </tr>
                <tr>
                    <td><code>PROMOTION_STORM</code></td>
                    <td>300 MB/s</td>
                    <td>1 GB (50% survival)</td>
                    <td>Old generation pressure</td>
                </tr>
                <tr>
                    <td><code>FRAGMENTATION</code></td>
                    <td>200 MB/s</td>
                    <td>1 GB fragmented</td>
                    <td>Compaction pauses</td>
                </tr>
                <tr>
                    <td><code>CROSS_GEN_REFS</code></td>
                    <td>150 MB/s</td>
                    <td>800 MB old gen</td>
                    <td>Remembered set overhead</td>
                </tr>
            </table>
            <p style="margin-top: 20px; font-size: 0.85em;">
                Each scenario uses <span class="highlight">4 parallel threads</span> to mirror production workloads.
            </p>
        </section>

        <!-- Slide 8: Cross-Gen Refs Deep Dive -->
        <section>
            <h2>CROSS_GEN_REFS: Remembered Set Stress</h2>
            <h3>Testing G1's Write Barrier Overhead</h3>
            <pre><code class="java" data-trim>
private static class RefHolder {
    volatile Object youngRef;  // Updated frequently
    final byte[] padding;      // 1MB to ensure old gen residence
}

private void createCrossGenerationalRefs(int bytes, int threads) {
    RefHolder[] holders = crossRefHolders.toArray(new RefHolder[0]);

    for (int t = 0; t < threads; t++) {
        futures[t] = CompletableFuture.runAsync(() -> {
            while (remaining > 0) {
                byte[] youngObj = new byte[size];
                // This write triggers G1's post-write barrier
                holders[idx].youngRef = youngObj;
                remaining -= size;
            }
        }, executorService);
    }
}
            </code></pre>
            <p style="margin-top: 15px;">
                <span class="failure">G1:</span> Every pointer update marks card table, adds to remembered set.<br>
                <span class="success">C4:</span> No generations = no remembered sets = no overhead.
            </p>
        </section>

        <!-- Section: Architecture -->
        <section>
            <h1 style="color: var(--payara-orange);">Part 2</h1>
            <h2>Architecture</h2>
            <p>Zero-copy pipeline design with Jakarta EE</p>
        </section>

        <!-- Slide 9: Architecture Overview -->
        <section>
            <h2>TradeStreamEE Architecture</h2>
            <h3>Zero-Copy Pipeline for Market Data</h3>
            <div class="architecture-diagram">
                <div class="arch-box"><strong>Publisher</strong><br>Market Data</div>
                <div class="arrow">→</div>
                <div class="arch-box"><strong>SBE</strong><br>Binary Encode</div>
                <div class="arrow">→</div>
                <div class="arch-box"><strong>Aeron IPC</strong><br>Shared Memory</div>
                <div class="arrow">→</div>
                <div class="arch-box"><strong>Payara</strong><br>WebSocket</div>
                <div class="arrow">→</div>
                <div class="arch-box"><strong>Browser</strong><br>Dashboard</div>
            </div>
            <div class="two-column" style="margin-top: 30px;">
                <div class="box">
                    <h3>Ingestion Layer</h3>
                    <ul>
                        <li><strong>Aeron IPC:</strong> Kernel bypass, shared memory</li>
                        <li><strong>SBE:</strong> Flyweight pattern, zero allocation</li>
                        <li>Sub-microsecond message latency</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Application Layer</h3>
                    <ul>
                        <li><strong>Payara Micro 7:</strong> Jakarta EE 11</li>
                        <li><strong>CDI:</strong> Lifecycle management</li>
                        <li><strong>WebSocket:</strong> Real-time push</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 9b: Dual-Mode Architecture -->
        <section>
            <h2>Dual-Mode Ingestion</h2>
            <h3>AERON vs DIRECT: Controlled Comparison</h3>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th style="color: #51cf66;">AERON Mode</th>
                    <th style="color: #ff6b6b;">DIRECT Mode</th>
                </tr>
                <tr>
                    <td>Encoding</td>
                    <td>SBE binary</td>
                    <td>JSON strings</td>
                </tr>
                <tr>
                    <td>Transport</td>
                    <td>Shared memory IPC</td>
                    <td>In-process calls</td>
                </tr>
                <tr>
                    <td>Allocation</td>
                    <td>~0 bytes/message</td>
                    <td>~1KB+ per message</td>
                </tr>
                <tr>
                    <td>GC Pressure</td>
                    <td>Minimal</td>
                    <td>High (intentional)</td>
                </tr>
                <tr>
                    <td>Purpose</td>
                    <td>Production pattern</td>
                    <td>GC stress baseline</td>
                </tr>
            </table>
            <div class="box" style="margin-top: 20px;">
                <p>DIRECT mode adds 1KB+ padding per message to stress the garbage collector. This isolates GC as the variable when comparing C4 vs G1.</p>
            </div>
        </section>

        <!-- Slide 9c: SBE Message Types -->
        <section>
            <h2>SBE Schema: 5 Message Types</h2>
            <h3>Defined in market-data.xml</h3>
            <table>
                <tr>
                    <th>Message</th>
                    <th>ID</th>
                    <th>Key Fields</th>
                </tr>
                <tr>
                    <td><code>Trade</code></td>
                    <td>1</td>
                    <td>timestamp, tradeId, price, quantity, side, symbol</td>
                </tr>
                <tr>
                    <td><code>Quote</code></td>
                    <td>2</td>
                    <td>timestamp, bidPrice, bidSize, askPrice, askSize, symbol</td>
                </tr>
                <tr>
                    <td><code>MarketDepth</code></td>
                    <td>3</td>
                    <td>bids[], asks[] (5 levels), sequenceNumber</td>
                </tr>
                <tr>
                    <td><code>OrderAck</code></td>
                    <td>4</td>
                    <td>orderId, execType, leavesQty, cumQty, side</td>
                </tr>
                <tr>
                    <td><code>Heartbeat</code></td>
                    <td>5</td>
                    <td>timestamp, sequenceNumber</td>
                </tr>
            </table>
            <p style="margin-top: 15px; font-size: 0.85em;">
                Price encoding: <code>int64 × 10,000</code> for 4 decimal places. Little-endian byte order.
            </p>
        </section>

        <!-- Slide 10: SBE Zero-Copy -->
        <section>
            <h2>SBE: Zero-Copy Message Processing</h2>
            <h3>The Flyweight Pattern</h3>
            <pre><code class="java" data-trim>
// Reusable decoders - no allocation in hot path
private final TradeDecoder tradeDecoder = new TradeDecoder();
private final MessageHeaderDecoder headerDecoder = new MessageHeaderDecoder();

@Override
public void onFragment(DirectBuffer buffer, int offset, int length, Header header) {
    // Wrap existing buffer - no copy
    headerDecoder.wrap(buffer, offset);

    // Move decoder "window" over buffer - no allocation
    tradeDecoder.wrap(buffer,
                     offset + headerDecoder.encodedLength(),
                     headerDecoder.blockLength(),
                     headerDecoder.version());

    // Read directly from buffer
    final long timestamp = tradeDecoder.timestamp();
    final long price = tradeDecoder.price();
    final long quantity = tradeDecoder.quantity();
}
            </code></pre>
            <p style="margin-top: 15px;">
                Decoders are views over byte buffers. No Java objects created during message processing.
            </p>
        </section>

        <!-- Slide 11: Aeron IPC -->
        <section>
            <h2>Aeron: Ultra-Low Latency Transport</h2>
            <h3>Bypassing the Kernel</h3>
            <div class="two-column">
                <div>
                    <h3 style="color: #ff6b6b;">Traditional Messaging</h3>
                    <ul>
                        <li>TCP/IP socket calls</li>
                        <li>Kernel context switches</li>
                        <li>Buffer copies at each layer</li>
                        <li>Serialization/deserialization</li>
                        <li>Latency: 10-100+ microseconds</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: #51cf66;">Aeron IPC</h3>
                    <ul>
                        <li>Memory-mapped files</li>
                        <li>Direct memory access</li>
                        <li>Zero-copy with SBE</li>
                        <li>No kernel involvement</li>
                        <li>Transport latency: sub-microsecond</li>
                    </ul>
                </div>
            </div>
            <div class="box" style="margin-top: 30px;">
                <p>Aeron's ring buffer in shared memory allows components on the same machine to communicate without network overhead. Combined with SBE, the entire path from publisher to subscriber involves no object allocation.</p>
                <p style="font-size: 0.75em; color: #888; margin-top: 10px;">Note: End-to-end latency includes WebSocket broadcast and JSON conversion. Transport layer is sub-microsecond.</p>
            </div>
        </section>

        <!-- Slide 11b: Aeron Configuration -->
        <section>
            <h2>Aeron Configuration Details</h2>
            <h3>Production-Ready Settings</h3>
            <table>
                <tr>
                    <th>Parameter</th>
                    <th>Value</th>
                    <th>Purpose</th>
                </tr>
                <tr>
                    <td><code>Channel</code></td>
                    <td><code>aeron:ipc</code></td>
                    <td>Inter-process communication mode</td>
                </tr>
                <tr>
                    <td><code>Stream ID</code></td>
                    <td>1001</td>
                    <td>Logical message stream identifier</td>
                </tr>
                <tr>
                    <td><code>Fragment Limit</code></td>
                    <td>10</td>
                    <td>Messages polled per iteration</td>
                </tr>
                <tr>
                    <td><code>Idle Strategy</code></td>
                    <td>BackoffIdleStrategy</td>
                    <td>100ns → 100μs adaptive backoff</td>
                </tr>
                <tr>
                    <td><code>Shared Memory</code></td>
                    <td>512 MB</td>
                    <td>IPC buffer size (Docker tmpfs)</td>
                </tr>
            </table>
            <div class="box" style="margin-top: 20px;">
                <h3>Circuit Breaker</h3>
                <p>Publisher stops after 50 consecutive offer failures to prevent resource exhaustion.</p>
            </div>
        </section>

        <!-- Slide 12: Payara Micro -->
        <section>
            <h2>Payara Micro 7.2025.2</h2>
            <h3>Jakarta EE 11 for Financial Applications</h3>
            <div class="two-column">
                <div class="box">
                    <h3>Features</h3>
                    <ul>
                        <li>~100MB footprint</li>
                        <li>Fast startup (seconds)</li>
                        <li>Jakarta CDI for DI</li>
                        <li>Jakarta WebSocket</li>
                        <li>Jakarta REST (JAX-RS)</li>
                        <li>Jakarta Concurrency 3.1</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Clustering</h3>
                    <ul>
                        <li>Hazelcast 5.5 built-in</li>
                        <li>TCP/IP discovery (Docker)</li>
                        <li>CP Subsystem for counters</li>
                        <li>Reliable Topics (back-pressure)</li>
                        <li>No external infrastructure</li>
                    </ul>
                </div>
            </div>
            <pre style="margin-top: 20px;"><code class="java" data-trim>
// Cluster-wide metrics without complex setup
@Inject private HazelcastInstance hazelcastInstance;

public void init() {
    clusterMessageCounter =
        hazelcastInstance.getCPSubsystem().getAtomicLong("cluster-message-count");
}
            </code></pre>
        </section>

        <!-- Slide 13: Virtual Threads -->
        <section>
            <h2>Jakarta Concurrency 3.1</h2>
            <h3>Virtual Threads for Memory Pressure Testing</h3>
            <pre><code class="java" data-trim>
@Inject
@VirtualThreadExecutor  // Jakarta Concurrency 3.1 - virtual threads
private ManagedExecutorService managedExecutorService;

private void allocateTransientGarbageMultiThreaded(int totalBytes, int numThreads) {
    int bytesPerThread = totalBytes / numThreads;
    CompletableFuture&lt;?&gt;[] futures = new CompletableFuture[numThreads];

    for (int t = 0; t < numThreads; t++) {
        futures[t] = CompletableFuture.runAsync(() -> {
            byte[] garbage = new byte[bytesPerThread];
            ThreadLocalRandom.current().nextBytes(garbage);
            totalBytesAllocated.addAndGet(bytesPerThread);
        }, managedExecutorService);
    }

    CompletableFuture.allOf(futures).join();
}
            </code></pre>
            <p style="margin-top: 15px;">
                4 parallel threads simulate production workloads where multiple request handlers allocate concurrently.
            </p>
        </section>

        <!-- Section: Results -->
        <section>
            <h1 style="color: var(--payara-orange);">Part 3</h1>
            <h2>Test Results</h2>
            <p>Measured GC behavior under stress scenarios</p>
        </section>

        <!-- Slide 14: Test Results -->
        <section>
            <h2>Test Results: G1 vs C4</h2>
            <h3>Under PROMOTION_STORM (300 MB/sec, 50% survival)</h3>
            <div class="comparison-row">
                <div class="comparison-item">
                    <div class="metric-large" style="color: #ff6b6b;">25ms</div>
                    <div class="metric-label">G1 Maximum Pause (measured)</div>
                </div>
                <div class="comparison-item">
                    <div class="metric-large" style="color: #51cf66;">2ms</div>
                    <div class="metric-label">C4 Maximum Pause (measured)</div>
                </div>
            </div>
            <div class="two-column" style="margin-top: 20px; font-size: 0.75em;">
                <div class="box">
                    <h3 style="color: #ff6b6b;">G1GC (Zulu 21)</h3>
                    <pre><code class="json" data-trim>
{
  "pauseP50Ms": 3, "pauseP95Ms": 16,
  "pauseP99Ms": 24, "pauseMaxMs": 25,
  "avgPauseMs": 4.87,
  "slaViolations10ms": 20
}
                    </code></pre>
                </div>
                <div class="box">
                    <h3 style="color: #51cf66;">C4/GPGC (Prime 21)</h3>
                    <pre><code class="json" data-trim>
{
  "pauseP50Ms": 0, "pauseP95Ms": 1,
  "pauseP99Ms": 1, "pauseMaxMs": 2,
  "avgPauseMs": 0.078,
  "slaViolations10ms": 0
}
                    </code></pre>
                </div>
            </div>
            <p style="margin-top: 15px; font-size: 0.85em;">
                Same workload, same allocation rate. G1: <span class="failure">20 SLA violations</span> | C4: <span class="success">Zero violations</span>
            </p>
        </section>

        <!-- Slide 15: GROWING_HEAP Results -->
        <section>
            <h2>GROWING_HEAP: Live Set Scaling</h2>
            <h3>100 MB → 2 GB over 60 seconds</h3>
            <div class="two-column">
                <div class="box">
                    <h3 style="color: #ff6b6b;">G1 Behavior</h3>
                    <ul>
                        <li>Young GC: 10-30ms initially</li>
                        <li>Mixed GC starts at ~500MB</li>
                        <li>Pause time grows with live set</li>
                        <li>At 2GB: 100-200ms pauses</li>
                        <li>Throughput degrades</li>
                    </ul>
                </div>
                <div class="box">
                    <h3 style="color: #51cf66;">C4 Behavior</h3>
                    <ul>
                        <li>Pause time: 0-1ms throughout</li>
                        <li>No mixed collection concept</li>
                        <li>Live set size irrelevant</li>
                        <li>At 2GB: still < 1ms</li>
                        <li>Consistent throughput</li>
                    </ul>
                </div>
            </div>
            <p style="margin-top: 30px;">
                G1's pause time scales with heap occupancy. C4's pause time remains constant.
            </p>
        </section>

        <!-- Slide 15b: Burst Pattern Simulation -->
        <section>
            <h2>Burst Pattern Simulation</h2>
            <h3>Realistic Market Conditions</h3>
            <div class="box">
                <p>The publisher simulates a 60-second market cycle:</p>
            </div>
            <table style="margin-top: 20px;">
                <tr>
                    <th>Time</th>
                    <th>Event</th>
                    <th>Rate Multiplier</th>
                </tr>
                <tr>
                    <td>0-20s</td>
                    <td>Normal trading</td>
                    <td>1x</td>
                </tr>
                <tr>
                    <td style="color: #ff6b6b;">20-25s</td>
                    <td style="color: #ff6b6b;">News event spike</td>
                    <td style="color: #ff6b6b;">5x burst</td>
                </tr>
                <tr>
                    <td>25-45s</td>
                    <td>Normal trading</td>
                    <td>1x</td>
                </tr>
                <tr>
                    <td style="color: var(--payara-orange);">45-50s</td>
                    <td style="color: var(--payara-orange);">Market close rush</td>
                    <td style="color: var(--payara-orange);">3x spike</td>
                </tr>
                <tr>
                    <td>50-60s</td>
                    <td>Normal trading</td>
                    <td>1x</td>
                </tr>
            </table>
            <p style="margin-top: 20px; font-size: 0.85em;">
                Tests GC response to variable load. G1 may trigger mixed collections during bursts; C4 adapts smoothly.
            </p>
        </section>

        <!-- Slide 15c: SLA Monitoring -->
        <section>
            <h2>SLA Violation Tracking</h2>
            <h3>Real-Time Compliance Monitoring</h3>
            <div class="two-column">
                <div class="box">
                    <h3>Tracked Thresholds</h3>
                    <ul>
                        <li><span class="success">< 10ms</span> - Within SLA</li>
                        <li><span style="color: var(--payara-orange);">> 10ms</span> - Minor violation</li>
                        <li><span class="failure">> 50ms</span> - Major violation</li>
                        <li><span class="failure">> 100ms</span> - Critical violation</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Metrics Collected</h3>
                    <ul>
                        <li>P50, P95, P99, P999 latency</li>
                        <li>All-time maximum pause</li>
                        <li>Total pause count and time</li>
                        <li>Violation counts by threshold</li>
                    </ul>
                </div>
            </div>
            <div class="two-column" style="margin-top: 20px; font-size: 0.7em;">
                <div class="box">
                    <h3 style="color: #ff6b6b;">G1GC SLA Stats</h3>
                    <pre><code class="json" data-trim>
{
  "totalPauseCount": 164,
  "totalPauseTimeMs": 799,
  "violationsOver10ms": 20,
  "violationsOver50ms": 0,
  "violationsOver100ms": 0
}
                    </code></pre>
                </div>
                <div class="box">
                    <h3 style="color: #51cf66;">C4 SLA Stats</h3>
                    <pre><code class="json" data-trim>
{
  "totalPauseCount": 665,
  "totalPauseTimeMs": 52,
  "violationsOver10ms": 0,
  "violationsOver50ms": 0,
  "violationsOver100ms": 0
}
                    </code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 16: Business Impact -->
        <section>
            <h2>Business Impact</h2>
            <h3>Why Pauseless Matters for Trading</h3>
            <div class="two-column">
                <div class="box">
                    <h3>Predictable Latency</h3>
                    <ul>
                        <li>SLA compliance guaranteed</li>
                        <li>No jitter during market events</li>
                        <li>Consistent execution speed</li>
                        <li>Regulatory requirements met</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Operational Simplicity</h3>
                    <ul>
                        <li>No GC tuning required</li>
                        <li>C4 adapts automatically</li>
                        <li>Fewer performance engineers</li>
                        <li>Reduced time-to-production</li>
                    </ul>
                </div>
            </div>
            <div class="box" style="margin-top: 30px;">
                <h3>Cost of a 100ms Pause</h3>
                <p>At 10,000 trades/second, a 100ms pause delays 1,000 trades. In markets where price moves in milliseconds, delayed trades execute at worse prices. Multiply by trading volume for financial impact.</p>
            </div>
        </section>

        <!-- Section: Demo & Deployment -->
        <section>
            <h1 style="color: var(--payara-orange);">Part 4</h1>
            <h2>Demo & Deployment</h2>
            <p>Running and monitoring the application</p>
        </section>

        <!-- Slide 17: Dashboard Demo -->
        <section>
            <h2>Live Dashboard</h2>
            <h3>Real-Time GC Visualization</h3>
            <img src="images/dashboard.png" alt="TradeStreamEE Dashboard" style="max-width: 90%; border: 2px solid var(--payara-orange); border-radius: 10px;">
            <p style="margin-top: 15px; font-size: 0.85em;">
                WebSocket-connected dashboard showing live message rates, GC pause percentiles, and SLA violations.
            </p>
        </section>

        <!-- Slide 17b: Deployment Options -->
        <section>
            <h2>Deployment Options</h2>
            <h3>Running TradeStreamEE</h3>
            <pre><code class="bash" data-trim>
# Single instance - Azul C4 with Aeron
./start.sh azul-aeron

# Single instance - Standard JDK with G1 (baseline)
./start.sh standard-direct

# Side-by-side comparison (C4 vs G1 clusters)
./start-comparison.sh all
            </code></pre>
            <div class="two-column" style="margin-top: 30px;">
                <div class="box">
                    <h3>Single Instance</h3>
                    <ul>
                        <li>8GB heap</li>
                        <li>Full throughput testing</li>
                        <li>AERON or DIRECT mode</li>
                    </ul>
                </div>
                <div class="box">
                    <h3>Comparison Stack</h3>
                    <ul>
                        <li>C4 cluster: ports 8080-8083</li>
                        <li>G1 cluster: ports 9080-9083</li>
                        <li>Grafana dashboards included</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 17c: Comparison Architecture -->
        <section>
            <h2>Comparison Stack Architecture</h2>
            <h3>Side-by-Side C4 vs G1 Testing</h3>
            <pre style="font-size: 0.7em; text-align: left;"><code data-trim>
┌─────────────────────────┐    ┌─────────────────────────┐
│   C4 Cluster (Prime)    │    │   G1 Cluster (Temurin)  │
│   └─ Traefik :8080      │    │   └─ Traefik :9080      │
│      ├─ instance-1      │    │      ├─ instance-1      │
│      ├─ instance-2      │    │      ├─ instance-2      │
│      └─ instance-3      │    │      └─ instance-3      │
│   JMX: 9010-9012        │    │   JMX: 9020-9022        │
└───────────┬─────────────┘    └───────────┬─────────────┘
            │                              │
            └──────────┬───────────────────┘
                       ▼
              ┌────────────────┐
              │   Prometheus   │──▶ Grafana :3000
              │    :9090       │
              └────────────────┘
            </code></pre>
            <p style="margin-top: 15px; font-size: 0.85em;">
                Both clusters run identical workloads. JMX Exporter exposes GC metrics to Prometheus.
            </p>
        </section>

        <!-- Slide 18: API Endpoints -->
        <section>
            <h2>Stress Testing API</h2>
            <h3>Applying Scenarios via REST</h3>
            <pre><code class="bash" data-trim>
# Apply scenarios
curl -X POST http://localhost:8080/api/pressure/mode/STEADY_LOAD
curl -X POST http://localhost:8080/api/pressure/mode/GROWING_HEAP
curl -X POST http://localhost:8080/api/pressure/mode/PROMOTION_STORM
curl -X POST http://localhost:8080/api/pressure/mode/FRAGMENTATION
curl -X POST http://localhost:8080/api/pressure/mode/CROSS_GEN_REFS
curl -X POST http://localhost:8080/api/pressure/mode/OFF

# Get GC statistics
curl http://localhost:8080/api/gc/stats

# Get current pressure status
curl http://localhost:8080/api/pressure/status
            </code></pre>
            <p style="margin-top: 15px;">
                The UI provides real-time visualization of GC pause times, percentiles, and allocation rates.
            </p>
        </section>

        <!-- Slide 19: Tech Stack Summary -->
        <section>
            <h2>Technology Stack</h2>
            <table>
                <tr>
                    <th>Component</th>
                    <th>Technology</th>
                    <th>Role</th>
                </tr>
                <tr>
                    <td>Runtime</td>
                    <td>Azul Platform Prime 21</td>
                    <td>C4/GPGC pauseless garbage collection</td>
                </tr>
                <tr>
                    <td>App Server</td>
                    <td>Payara Micro 7.2025.2</td>
                    <td>Jakarta EE 11 container</td>
                </tr>
                <tr>
                    <td>Transport</td>
                    <td>Aeron 1.46.7</td>
                    <td>Shared memory IPC messaging</td>
                </tr>
                <tr>
                    <td>Encoding</td>
                    <td>SBE 1.34.0</td>
                    <td>Zero-copy binary serialization</td>
                </tr>
                <tr>
                    <td>Clustering</td>
                    <td>Hazelcast 5.5.0</td>
                    <td>Distributed topics and CP subsystem</td>
                </tr>
                <tr>
                    <td>Monitoring</td>
                    <td>Prometheus + Grafana</td>
                    <td>JMX metrics and visualization</td>
                </tr>
            </table>
        </section>

        <!-- Slide 20: Key Takeaways -->
        <section>
            <h2>Key Takeaways</h2>
            <ol style="font-size: 0.85em;">
                <li><strong>G1's stop-the-world pauses are architectural</strong> - no tuning eliminates them</li>
                <li><strong>C4/GPGC collects concurrently</strong> - application never stops</li>
                <li><strong>Pause time in G1 scales with live set</strong> - larger heaps = longer pauses</li>
                <li><strong>C4 pause time is constant</strong> - regardless of heap or live set size</li>
                <li><strong>Remembered sets add overhead in G1</strong> - cross-gen refs trigger write barriers</li>
                <li><strong>C4 collects generations concurrently</strong> - no STW for generational collection</li>
                <li><strong>Scenario-based testing exposes weaknesses</strong> - targeted stress reveals true behavior</li>
                <li><strong>Enterprise Java can achieve HFT latency</strong> - with the right runtime</li>
            </ol>
        </section>

        <!-- Slide 21: Resources -->
        <section>
            <h2>Resources</h2>
            <div class="box" style="margin-bottom: 30px;">
                <h3>TradeStreamEE Features</h3>
                <ul style="font-size: 0.85em; text-align: left;">
                    <li>Scenario-based GC stress testing (6 allocation modes)</li>
                    <li>Real-time pause time visualization</li>
                    <li>Side-by-side C4 vs G1 comparison clusters</li>
                    <li>Zero-copy message pipeline (Aeron 1.46.7 + SBE 1.34.0)</li>
                    <li>Hazelcast 5.5 clustering with reliable topics</li>
                    <li>Prometheus/Grafana monitoring stack</li>
                </ul>
            </div>
            <h3>Learn More</h3>
            <ul style="font-size: 0.9em;">
                <li>Azul Platform Prime: <code>azul.com/products/prime</code></li>
                <li>Payara Platform: <code>payara.fish</code></li>
                <li>Aeron: <code>aeron.io</code></li>
                <li>SBE: <code>real-logic.github.io/simple-binary-encoding</code></li>
            </ul>
        </section>

        <!-- Slide 21b: Lessons Learned -->
        <section>
            <h2>Lessons Learned</h2>
            <h3>Practical Insights from Implementation</h3>
            <div class="two-column">
                <div class="box">
                    <h3 style="color: #51cf66;">What Worked</h3>
                    <ul style="font-size: 0.85em;">
                        <li>SBE flyweight pattern eliminates allocation</li>
                        <li>Aeron IPC provides true zero-copy</li>
                        <li>C4 requires no tuning for consistent pauses</li>
                        <li>Scenario-based testing reveals real behavior</li>
                    </ul>
                </div>
                <div class="box">
                    <h3 style="color: var(--payara-orange);">Watch Out For</h3>
                    <ul style="font-size: 0.85em;">
                        <li>GPGC reports as collector name, not "C4"</li>
                        <li>WebSocket JSON conversion adds latency</li>
                        <li>1-in-50 sampling needed for UI stability</li>
                        <li>Docker shared memory sizing for Aeron</li>
                    </ul>
                </div>
            </div>
            <div class="box" style="margin-top: 20px;">
                <p style="font-size: 0.9em;"><strong>Key Insight:</strong> The application code stays simple. The GC choice handles the complexity of memory management without code changes.</p>
            </div>
        </section>

        <!-- Slide 22: Thank You -->
        <section>
            <img alt="Payara" class="payara-logo" src="images/payara-fish-logo.svg">
            <h1>Thank You</h1>
            <h3>Questions?</h3>
            <div style="margin-top: 60px; font-size: 1.1em;">
                <p><strong>GitHub:</strong> github.com/pedanticdev/trader-stream-ee</p>
            </div>
        </section>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        loop: true,
        transition: 'slide',
        backgroundTransition: 'fade',
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        width: 1280,
        height: 720,
        margin: 0.1,
        minScale: 0.2,
        maxScale: 2.0
    });
</script>
</body>
</html>
